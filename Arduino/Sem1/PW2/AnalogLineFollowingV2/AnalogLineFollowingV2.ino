#include <LiquidCrystal.h>

// // Pin definitions
// Encoders
const int ENCODER_LEFT = 1;
const int ENCODER_RIGHT = 2;

// IR Sensors
const int IR_LEFT = A4;
const int IR_RIGHT = A5;

// Motor controls
const int ENA = 11;  // Enable right-side pair of motors -- Pair A
const int ENB = 3;   // Enable left-side pair of motors -- Pair B
const int IN1 = A1;  // Command Pair A forwards
const int IN3 = 12;  // Command Pair A backwards
const int IN2 = A2;  // Command Pair B forwards
const int IN4 = 13;  //Command Pair B backwards

// ------------------------------------------------
// ------------------------------------------------

// // LCD
// LCD control pins
const int
  REGISTER_SELECT = 8,
  ENABLE = 9,
  DB4 = 4,
  DB5 = 5,
  DB6 = 6,
  DB7 = 7;
// Initialize the LCD
LiquidCrystal lcd(REGISTER_SELECT, ENABLE, DB4, DB5, DB6, DB7);

// ------------------------------------------------
// ------------------------------------------------

// // Distance

// Variables for measuring distance traveled
// Minimum distance = 955 cm
// Maximum distance = 993 cm
float distance = 0.0;                    // Calculated distance in centimeters
const float WHEEL_RADIUS = 3.0;          // Radius of the wheels of the line following car in centimeters
const float PULSES_PER_REVOLUTION = 20;  // Number of pulses generated by the encoder wheel for one full revolution
volatile int encLeft_highCount = 0;      // Count of '1's for ENCODER_LEFT
volatile int encRight_highCount = 0;     // Count of '1's for ENCODER_RIGHT
// volatile int encLeft_prevState = LOW;    // Previous state of ENCODER_LEFT
// volatile int encRight_prevState = LOW;   // Previous state of ENCODER_RIGHT

// Time tracking variables
unsigned long startTime = 0;
unsigned long elapsedTime = 0;
bool carMoving = false;

// // Distance Calculations Interrupts
// Interrupt Service Routine (ISR) for ENCODER_LEFT

// void encoderLeft_ISR() {
//   const int currentState = digitalRead(ENCODER_LEFT);      // Get encoder state
//   if (currentState == HIGH && encLeft_prevState == LOW) {  // Detect rising edge
//     encLeft_highCount++;                                   // Increase count of encoder highs if rising edge is detected
//   }
//   encLeft_prevState = currentState;  // Update the previous state variable with the current state of the encoder
// }
void encoderLeft_ISR() {
  encLeft_highCount++;  // Increase count of encoder highs if rising edge is detected
}

// Interrupt Service Routine (ISR) for ENCODER_RIGHT
// void encoderRight_ISR() {
//   const int currentState = digitalRead(ENCODER_RIGHT);      // Get encoder state
//   if (currentState == HIGH && encRight_prevState == LOW) {  // Detect rising edge
//     encRight_highCount++;                                   // Increase count of encoder highs if rising edge is detected
//   }
//   encRight_prevState = currentState;  // Update the previous state variable with the current state of the encoder
// }
void encoderRight_ISR() {
  encRight_highCount++;  // Increase count of encoder highs if rising edge is detected
}

// ------------------------------------------------
// ------------------------------------------------

//// Line following

const int
  mainSpeed = 75,   // main speed of the LFC (Line Following Car)
  highSpeed = 255,  // higher speed of the LFC
  lowSpeed = 0;     // lower speed of the LFC

const int IR_THRESHOLD = 200;  // Threshold for line detection

// Movement functions
void moveForward() {
  // Speed control
  analogWrite(ENA, mainSpeed);
  analogWrite(ENB, mainSpeed);
  // Direction control
  digitalWrite(IN1, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, LOW);
}
void moveLeft() {
  // Speed control
  analogWrite(ENA, highSpeed);
  analogWrite(ENB, highSpeed);
  // Direction control
  digitalWrite(IN1, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, HIGH);
}
void moveRight() {
  // Speed control
  analogWrite(ENA, highSpeed);
  analogWrite(ENB, highSpeed);
  // Direction control
  digitalWrite(IN1, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN4, LOW);
}
void moveStop() {
  // Speed control
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // Direction control
  digitalWrite(IN1, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, LOW);

  if (carMoving == true) {
    carMoving = false;
  }
}

// ------------------------------------------------
// ------------------------------------------------

void setup() {
  // Set up Encoder Pin as input
  pinMode(ENCODER_LEFT, INPUT);
  pinMode(ENCODER_RIGHT, INPUT);

  // Set up IR sensor pins as input
  pinMode(IR_LEFT, INPUT);
  pinMode(IR_RIGHT, INPUT);

  // Set up motor pins
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN4, OUTPUT);

  // Attach interrupt to the encoder pins
  // attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), encoderLeft_ISR, CHANGE);
  // attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), encoderRight_ISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), encoderLeft_ISR, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), encoderRight_ISR, RISING);

  // Initialize the LCD
  lcd.begin(16, 2);  // Set up the LCD with 16 columns and 2 rows
  lcd.print("Starting run...");

  // Initialize Serial Communication
  // Serial.begin(9600);  // Start Serial at 9600 baud rate

  delay(600);   // Wait a little before starting to move
  lcd.clear();  // Clear LCD
}

void loop() {
  // Calculate distance
  float encoderAverage = (float)(encLeft_highCount + encRight_highCount) / 2.0;
  distance = (encoderAverage * (2 * PI * WHEEL_RADIUS)) / PULSES_PER_REVOLUTION;  // distance is in centimeters

  // Display distance on the LCD
  lcd.setCursor(0, 0);      // Move to the first row
  lcd.print("Distance:");   // Print "Distance"
  lcd.setCursor(0, 1);      // Move to the second row
  lcd.print(distance, 2);   // Print distance with 2 decimal places
  lcd.print(" cm       ");  // Clear trailing characters

  // // Read IR sensor values
  int leftSensor = analogRead(IR_LEFT);
  int rightSensor = analogRead(IR_RIGHT);

  // // Print IR info
  // Serial.print("IR Right: ");
  // Serial.print(rightSensor);
  // Serial.println("");
  // Serial.print("IR Left: ");
  // Serial.print(leftSensor);
  // Serial.println("");

  // // Line-following logic
  // Neither sensor is seeing the line, move straight
  if (rightSensor > IR_THRESHOLD && leftSensor > IR_THRESHOLD) {
    moveForward();
  }
  // Left sensor is seeing the line, turn left
  if (leftSensor < IR_THRESHOLD && rightSensor > IR_THRESHOLD) {
    moveLeft()
  }
  // Right sensor is seeing the line, turn right
  if (rightSensor < IR_THRESHOLD && leftSensor > IR_THRESHOLD) {
    moveRight()
  }
  // Both sensors are seeing the line, stop
  if (leftSensor < IR_THRESHOLD && rightSensor < IR_THRESHOLD) {
    moveStop()
  }

  // Print distance to Serial Monitor
  // Serial.print("Distance: ");
  // Serial.print(distance, 2);  // Print with 2 decimal places
  // Serial.println("m");

  delay(30);  // Adjust the delay for smoother updates
}
